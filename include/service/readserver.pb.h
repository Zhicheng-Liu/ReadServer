// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: readserver.proto

#ifndef PROTOBUF_readserver_2eproto__INCLUDED
#define PROTOBUF_readserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_readserver_2eproto();
void protobuf_AssignDesc_readserver_2eproto();
void protobuf_ShutdownFile_readserver_2eproto();

class ReadInfo;
class Reply;
class ReplyAll;
class ReplyCount;
class ReplyReads;
class Request;
class ResultAll;
class ResultCount;
class ResultReads;
class ResultSamples;

enum Request_RequestType {
  Request_RequestType_CountReads = 1,
  Request_RequestType_ExactMatch = 2,
  Request_RequestType_KmerMatch = 3,
  Request_RequestType_SiteMatch = 4
};
bool Request_RequestType_IsValid(int value);
const Request_RequestType Request_RequestType_RequestType_MIN = Request_RequestType_CountReads;
const Request_RequestType Request_RequestType_RequestType_MAX = Request_RequestType_SiteMatch;
const int Request_RequestType_RequestType_ARRAYSIZE = Request_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor();
inline const ::std::string& Request_RequestType_Name(Request_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_RequestType_descriptor(), value);
}
inline bool Request_RequestType_Parse(
    const ::std::string& name, Request_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_RequestType>(
    Request_RequestType_descriptor(), name, value);
}
enum Request_ReturnType {
  Request_ReturnType_Count = 1,
  Request_ReturnType_Reads = 2,
  Request_ReturnType_All = 3,
  Request_ReturnType_Samples = 4
};
bool Request_ReturnType_IsValid(int value);
const Request_ReturnType Request_ReturnType_ReturnType_MIN = Request_ReturnType_Count;
const Request_ReturnType Request_ReturnType_ReturnType_MAX = Request_ReturnType_Samples;
const int Request_ReturnType_ReturnType_ARRAYSIZE = Request_ReturnType_ReturnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_ReturnType_descriptor();
inline const ::std::string& Request_ReturnType_Name(Request_ReturnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_ReturnType_descriptor(), value);
}
inline bool Request_ReturnType_Parse(
    const ::std::string& name, Request_ReturnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_ReturnType>(
    Request_ReturnType_descriptor(), name, value);
}
enum Reply_RequestType {
  Reply_RequestType_CountReads = 1,
  Reply_RequestType_ExactMatch = 2,
  Reply_RequestType_KmerMatch = 3,
  Reply_RequestType_SiteMatch = 4
};
bool Reply_RequestType_IsValid(int value);
const Reply_RequestType Reply_RequestType_RequestType_MIN = Reply_RequestType_CountReads;
const Reply_RequestType Reply_RequestType_RequestType_MAX = Reply_RequestType_SiteMatch;
const int Reply_RequestType_RequestType_ARRAYSIZE = Reply_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_RequestType_descriptor();
inline const ::std::string& Reply_RequestType_Name(Reply_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_RequestType_descriptor(), value);
}
inline bool Reply_RequestType_Parse(
    const ::std::string& name, Reply_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_RequestType>(
    Reply_RequestType_descriptor(), name, value);
}
enum Reply_ReplyType {
  Reply_ReplyType_ReplyCount = 1,
  Reply_ReplyType_ReplyReads = 2,
  Reply_ReplyType_ReplyAll = 3,
  Reply_ReplyType_ResultSamples = 4
};
bool Reply_ReplyType_IsValid(int value);
const Reply_ReplyType Reply_ReplyType_ReplyType_MIN = Reply_ReplyType_ReplyCount;
const Reply_ReplyType Reply_ReplyType_ReplyType_MAX = Reply_ReplyType_ResultSamples;
const int Reply_ReplyType_ReplyType_ARRAYSIZE = Reply_ReplyType_ReplyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_ReplyType_descriptor();
inline const ::std::string& Reply_ReplyType_Name(Reply_ReplyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_ReplyType_descriptor(), value);
}
inline bool Reply_ReplyType_Parse(
    const ::std::string& name, Reply_ReplyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_ReplyType>(
    Reply_ReplyType_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_RequestType RequestType;
  static const RequestType CountReads = Request_RequestType_CountReads;
  static const RequestType ExactMatch = Request_RequestType_ExactMatch;
  static const RequestType KmerMatch = Request_RequestType_KmerMatch;
  static const RequestType SiteMatch = Request_RequestType_SiteMatch;
  static inline bool RequestType_IsValid(int value) {
    return Request_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    Request_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    Request_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    Request_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return Request_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return Request_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return Request_RequestType_Parse(name, value);
  }

  typedef Request_ReturnType ReturnType;
  static const ReturnType Count = Request_ReturnType_Count;
  static const ReturnType Reads = Request_ReturnType_Reads;
  static const ReturnType All = Request_ReturnType_All;
  static const ReturnType Samples = Request_ReturnType_Samples;
  static inline bool ReturnType_IsValid(int value) {
    return Request_ReturnType_IsValid(value);
  }
  static const ReturnType ReturnType_MIN =
    Request_ReturnType_ReturnType_MIN;
  static const ReturnType ReturnType_MAX =
    Request_ReturnType_ReturnType_MAX;
  static const int ReturnType_ARRAYSIZE =
    Request_ReturnType_ReturnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReturnType_descriptor() {
    return Request_ReturnType_descriptor();
  }
  static inline const ::std::string& ReturnType_Name(ReturnType value) {
    return Request_ReturnType_Name(value);
  }
  static inline bool ReturnType_Parse(const ::std::string& name,
      ReturnType* value) {
    return Request_ReturnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Request.RequestType t = 1;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 1;
  ::Request_RequestType t() const;
  void set_t(::Request_RequestType value);

  // required .Request.ReturnType rt = 2;
  bool has_rt() const;
  void clear_rt();
  static const int kRtFieldNumber = 2;
  ::Request_ReturnType rt() const;
  void set_rt(::Request_ReturnType value);

  // required string q = 3;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 3;
  const ::std::string& q() const;
  void set_q(const ::std::string& value);
  void set_q(const char* value);
  void set_q(const char* value, size_t size);
  ::std::string* mutable_q();
  ::std::string* release_q();
  void set_allocated_q(::std::string* q);

  // optional int32 k = 4;
  bool has_k() const;
  void clear_k();
  static const int kKFieldNumber = 4;
  ::google::protobuf::int32 k() const;
  void set_k(::google::protobuf::int32 value);

  // optional int32 s = 5;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 5;
  ::google::protobuf::int32 s() const;
  void set_s(::google::protobuf::int32 value);

  // optional int32 p = 6;
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 6;
  ::google::protobuf::int32 p() const;
  void set_p(::google::protobuf::int32 value);

  // optional string a = 7;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 7;
  const ::std::string& a() const;
  void set_a(const ::std::string& value);
  void set_a(const char* value);
  void set_a(const char* value, size_t size);
  ::std::string* mutable_a();
  ::std::string* release_a();
  void set_allocated_a(::std::string* a);

  // optional int32 isalt = 8;
  bool has_isalt() const;
  void clear_isalt();
  static const int kIsaltFieldNumber = 8;
  ::google::protobuf::int32 isalt() const;
  void set_isalt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_rt();
  inline void clear_has_rt();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_isalt();
  inline void clear_has_isalt();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int t_;
  int rt_;
  ::google::protobuf::internal::ArenaStringPtr q_;
  ::google::protobuf::int32 k_;
  ::google::protobuf::int32 s_;
  ::google::protobuf::internal::ArenaStringPtr a_;
  ::google::protobuf::int32 p_;
  ::google::protobuf::int32 isalt_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class ReadInfo : public ::google::protobuf::Message {
 public:
  ReadInfo();
  virtual ~ReadInfo();

  ReadInfo(const ReadInfo& from);

  inline ReadInfo& operator=(const ReadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadInfo& default_instance();

  void Swap(ReadInfo* other);

  // implements Message ----------------------------------------------

  inline ReadInfo* New() const { return New(NULL); }

  ReadInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadInfo& from);
  void MergeFrom(const ReadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string g = 1;
  bool has_g() const;
  void clear_g();
  static const int kGFieldNumber = 1;
  const ::std::string& g() const;
  void set_g(const ::std::string& value);
  void set_g(const char* value);
  void set_g(const char* value, size_t size);
  ::std::string* mutable_g();
  ::std::string* release_g();
  void set_allocated_g(::std::string* g);

  // required int32 c = 2;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 2;
  ::google::protobuf::int32 c() const;
  void set_c(::google::protobuf::int32 value);

  // required int32 l = 3;
  bool has_l() const;
  void clear_l();
  static const int kLFieldNumber = 3;
  ::google::protobuf::int32 l() const;
  void set_l(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ReadInfo)
 private:
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_c();
  inline void clear_has_c();
  inline void set_has_l();
  inline void clear_has_l();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr g_;
  ::google::protobuf::int32 c_;
  ::google::protobuf::int32 l_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ReadInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResultSamples : public ::google::protobuf::Message {
 public:
  ResultSamples();
  virtual ~ResultSamples();

  ResultSamples(const ResultSamples& from);

  inline ResultSamples& operator=(const ResultSamples& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultSamples& default_instance();

  void Swap(ResultSamples* other);

  // implements Message ----------------------------------------------

  inline ResultSamples* New() const { return New(NULL); }

  ResultSamples* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultSamples& from);
  void MergeFrom(const ResultSamples& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultSamples* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ReadInfo s = 1;
  int s_size() const;
  void clear_s();
  static const int kSFieldNumber = 1;
  const ::ReadInfo& s(int index) const;
  ::ReadInfo* mutable_s(int index);
  ::ReadInfo* add_s();
  ::google::protobuf::RepeatedPtrField< ::ReadInfo >*
      mutable_s();
  const ::google::protobuf::RepeatedPtrField< ::ReadInfo >&
      s() const;

  // @@protoc_insertion_point(class_scope:ResultSamples)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ReadInfo > s_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ResultSamples* default_instance_;
};
// -------------------------------------------------------------------

class ResultAll : public ::google::protobuf::Message {
 public:
  ResultAll();
  virtual ~ResultAll();

  ResultAll(const ResultAll& from);

  inline ResultAll& operator=(const ResultAll& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultAll& default_instance();

  void Swap(ResultAll* other);

  // implements Message ----------------------------------------------

  inline ResultAll* New() const { return New(NULL); }

  ResultAll* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultAll& from);
  void MergeFrom(const ResultAll& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultAll* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  void set_r(const char* value);
  void set_r(const char* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // repeated .ReadInfo s = 2;
  int s_size() const;
  void clear_s();
  static const int kSFieldNumber = 2;
  const ::ReadInfo& s(int index) const;
  ::ReadInfo* mutable_s(int index);
  ::ReadInfo* add_s();
  ::google::protobuf::RepeatedPtrField< ::ReadInfo >*
      mutable_s();
  const ::google::protobuf::RepeatedPtrField< ::ReadInfo >&
      s() const;

  // @@protoc_insertion_point(class_scope:ResultAll)
 private:
  inline void set_has_r();
  inline void clear_has_r();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::RepeatedPtrField< ::ReadInfo > s_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ResultAll* default_instance_;
};
// -------------------------------------------------------------------

class ResultCount : public ::google::protobuf::Message {
 public:
  ResultCount();
  virtual ~ResultCount();

  ResultCount(const ResultCount& from);

  inline ResultCount& operator=(const ResultCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultCount& default_instance();

  void Swap(ResultCount* other);

  // implements Message ----------------------------------------------

  inline ResultCount* New() const { return New(NULL); }

  ResultCount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultCount& from);
  void MergeFrom(const ResultCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 c = 1;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 1;
  ::google::protobuf::int32 c() const;
  void set_c(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ResultCount)
 private:
  inline void set_has_c();
  inline void clear_has_c();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 c_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ResultCount* default_instance_;
};
// -------------------------------------------------------------------

class ResultReads : public ::google::protobuf::Message {
 public:
  ResultReads();
  virtual ~ResultReads();

  ResultReads(const ResultReads& from);

  inline ResultReads& operator=(const ResultReads& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultReads& default_instance();

  void Swap(ResultReads* other);

  // implements Message ----------------------------------------------

  inline ResultReads* New() const { return New(NULL); }

  ResultReads* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultReads& from);
  void MergeFrom(const ResultReads& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultReads* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  void set_r(const char* value);
  void set_r(const char* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // @@protoc_insertion_point(class_scope:ResultReads)
 private:
  inline void set_has_r();
  inline void clear_has_r();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ResultReads* default_instance_;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  void Swap(Reply* other);

  // implements Message ----------------------------------------------

  inline Reply* New() const { return New(NULL); }

  Reply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reply_RequestType RequestType;
  static const RequestType CountReads = Reply_RequestType_CountReads;
  static const RequestType ExactMatch = Reply_RequestType_ExactMatch;
  static const RequestType KmerMatch = Reply_RequestType_KmerMatch;
  static const RequestType SiteMatch = Reply_RequestType_SiteMatch;
  static inline bool RequestType_IsValid(int value) {
    return Reply_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    Reply_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    Reply_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    Reply_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return Reply_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return Reply_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return Reply_RequestType_Parse(name, value);
  }

  typedef Reply_ReplyType ReplyType;
  static const ReplyType ReplyCount = Reply_ReplyType_ReplyCount;
  static const ReplyType ReplyReads = Reply_ReplyType_ReplyReads;
  static const ReplyType ReplyAll = Reply_ReplyType_ReplyAll;
  static const ReplyType ResultSamples = Reply_ReplyType_ResultSamples;
  static inline bool ReplyType_IsValid(int value) {
    return Reply_ReplyType_IsValid(value);
  }
  static const ReplyType ReplyType_MIN =
    Reply_ReplyType_ReplyType_MIN;
  static const ReplyType ReplyType_MAX =
    Reply_ReplyType_ReplyType_MAX;
  static const int ReplyType_ARRAYSIZE =
    Reply_ReplyType_ReplyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReplyType_descriptor() {
    return Reply_ReplyType_descriptor();
  }
  static inline const ::std::string& ReplyType_Name(ReplyType value) {
    return Reply_ReplyType_Name(value);
  }
  static inline bool ReplyType_Parse(const ::std::string& name,
      ReplyType* value) {
    return Reply_ReplyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Reply.RequestType rt = 1;
  bool has_rt() const;
  void clear_rt();
  static const int kRtFieldNumber = 1;
  ::Reply_RequestType rt() const;
  void set_rt(::Reply_RequestType value);

  // required .Reply.ReplyType t = 2;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 2;
  ::Reply_ReplyType t() const;
  void set_t(::Reply_ReplyType value);

  // required string q = 3;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 3;
  const ::std::string& q() const;
  void set_q(const ::std::string& value);
  void set_q(const char* value);
  void set_q(const char* value, size_t size);
  ::std::string* mutable_q();
  ::std::string* release_q();
  void set_allocated_q(::std::string* q);

  // optional .ReplyCount c = 4;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 4;
  const ::ReplyCount& c() const;
  ::ReplyCount* mutable_c();
  ::ReplyCount* release_c();
  void set_allocated_c(::ReplyCount* c);

  // optional .ReplyReads r = 5;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 5;
  const ::ReplyReads& r() const;
  ::ReplyReads* mutable_r();
  ::ReplyReads* release_r();
  void set_allocated_r(::ReplyReads* r);

  // optional .ReplyAll a = 6;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 6;
  const ::ReplyAll& a() const;
  ::ReplyAll* mutable_a();
  ::ReplyAll* release_a();
  void set_allocated_a(::ReplyAll* a);

  // optional .ResultSamples s = 7;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 7;
  const ::ResultSamples& s() const;
  ::ResultSamples* mutable_s();
  ::ResultSamples* release_s();
  void set_allocated_s(::ResultSamples* s);

  // @@protoc_insertion_point(class_scope:Reply)
 private:
  inline void set_has_rt();
  inline void clear_has_rt();
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_c();
  inline void clear_has_c();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_s();
  inline void clear_has_s();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int rt_;
  int t_;
  ::google::protobuf::internal::ArenaStringPtr q_;
  ::ReplyCount* c_;
  ::ReplyReads* r_;
  ::ReplyAll* a_;
  ::ResultSamples* s_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static Reply* default_instance_;
};
// -------------------------------------------------------------------

class ReplyAll : public ::google::protobuf::Message {
 public:
  ReplyAll();
  virtual ~ReplyAll();

  ReplyAll(const ReplyAll& from);

  inline ReplyAll& operator=(const ReplyAll& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyAll& default_instance();

  void Swap(ReplyAll* other);

  // implements Message ----------------------------------------------

  inline ReplyAll* New() const { return New(NULL); }

  ReplyAll* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyAll& from);
  void MergeFrom(const ReplyAll& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReplyAll* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ResultAll forward_matches = 1;
  int forward_matches_size() const;
  void clear_forward_matches();
  static const int kForwardMatchesFieldNumber = 1;
  const ::ResultAll& forward_matches(int index) const;
  ::ResultAll* mutable_forward_matches(int index);
  ::ResultAll* add_forward_matches();
  ::google::protobuf::RepeatedPtrField< ::ResultAll >*
      mutable_forward_matches();
  const ::google::protobuf::RepeatedPtrField< ::ResultAll >&
      forward_matches() const;

  // repeated .ResultAll revcomp_matches = 2;
  int revcomp_matches_size() const;
  void clear_revcomp_matches();
  static const int kRevcompMatchesFieldNumber = 2;
  const ::ResultAll& revcomp_matches(int index) const;
  ::ResultAll* mutable_revcomp_matches(int index);
  ::ResultAll* add_revcomp_matches();
  ::google::protobuf::RepeatedPtrField< ::ResultAll >*
      mutable_revcomp_matches();
  const ::google::protobuf::RepeatedPtrField< ::ResultAll >&
      revcomp_matches() const;

  // @@protoc_insertion_point(class_scope:ReplyAll)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ResultAll > forward_matches_;
  ::google::protobuf::RepeatedPtrField< ::ResultAll > revcomp_matches_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ReplyAll* default_instance_;
};
// -------------------------------------------------------------------

class ReplyCount : public ::google::protobuf::Message {
 public:
  ReplyCount();
  virtual ~ReplyCount();

  ReplyCount(const ReplyCount& from);

  inline ReplyCount& operator=(const ReplyCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyCount& default_instance();

  void Swap(ReplyCount* other);

  // implements Message ----------------------------------------------

  inline ReplyCount* New() const { return New(NULL); }

  ReplyCount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyCount& from);
  void MergeFrom(const ReplyCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReplyCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ResultCount forward_matches = 1;
  bool has_forward_matches() const;
  void clear_forward_matches();
  static const int kForwardMatchesFieldNumber = 1;
  const ::ResultCount& forward_matches() const;
  ::ResultCount* mutable_forward_matches();
  ::ResultCount* release_forward_matches();
  void set_allocated_forward_matches(::ResultCount* forward_matches);

  // optional .ResultCount revcomp_matches = 2;
  bool has_revcomp_matches() const;
  void clear_revcomp_matches();
  static const int kRevcompMatchesFieldNumber = 2;
  const ::ResultCount& revcomp_matches() const;
  ::ResultCount* mutable_revcomp_matches();
  ::ResultCount* release_revcomp_matches();
  void set_allocated_revcomp_matches(::ResultCount* revcomp_matches);

  // @@protoc_insertion_point(class_scope:ReplyCount)
 private:
  inline void set_has_forward_matches();
  inline void clear_has_forward_matches();
  inline void set_has_revcomp_matches();
  inline void clear_has_revcomp_matches();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ResultCount* forward_matches_;
  ::ResultCount* revcomp_matches_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ReplyCount* default_instance_;
};
// -------------------------------------------------------------------

class ReplyReads : public ::google::protobuf::Message {
 public:
  ReplyReads();
  virtual ~ReplyReads();

  ReplyReads(const ReplyReads& from);

  inline ReplyReads& operator=(const ReplyReads& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyReads& default_instance();

  void Swap(ReplyReads* other);

  // implements Message ----------------------------------------------

  inline ReplyReads* New() const { return New(NULL); }

  ReplyReads* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyReads& from);
  void MergeFrom(const ReplyReads& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReplyReads* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ResultReads forward_matches = 1;
  int forward_matches_size() const;
  void clear_forward_matches();
  static const int kForwardMatchesFieldNumber = 1;
  const ::ResultReads& forward_matches(int index) const;
  ::ResultReads* mutable_forward_matches(int index);
  ::ResultReads* add_forward_matches();
  ::google::protobuf::RepeatedPtrField< ::ResultReads >*
      mutable_forward_matches();
  const ::google::protobuf::RepeatedPtrField< ::ResultReads >&
      forward_matches() const;

  // repeated .ResultReads revcomp_matches = 2;
  int revcomp_matches_size() const;
  void clear_revcomp_matches();
  static const int kRevcompMatchesFieldNumber = 2;
  const ::ResultReads& revcomp_matches(int index) const;
  ::ResultReads* mutable_revcomp_matches(int index);
  ::ResultReads* add_revcomp_matches();
  ::google::protobuf::RepeatedPtrField< ::ResultReads >*
      mutable_revcomp_matches();
  const ::google::protobuf::RepeatedPtrField< ::ResultReads >&
      revcomp_matches() const;

  // @@protoc_insertion_point(class_scope:ReplyReads)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ResultReads > forward_matches_;
  ::google::protobuf::RepeatedPtrField< ::ResultReads > revcomp_matches_;
  friend void  protobuf_AddDesc_readserver_2eproto();
  friend void protobuf_AssignDesc_readserver_2eproto();
  friend void protobuf_ShutdownFile_readserver_2eproto();

  void InitAsDefaultInstance();
  static ReplyReads* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Request

// required .Request.RequestType t = 1;
inline bool Request::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_t() {
  t_ = 1;
  clear_has_t();
}
inline ::Request_RequestType Request::t() const {
  // @@protoc_insertion_point(field_get:Request.t)
  return static_cast< ::Request_RequestType >(t_);
}
inline void Request::set_t(::Request_RequestType value) {
  assert(::Request_RequestType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:Request.t)
}

// required .Request.ReturnType rt = 2;
inline bool Request::has_rt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_rt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_rt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_rt() {
  rt_ = 1;
  clear_has_rt();
}
inline ::Request_ReturnType Request::rt() const {
  // @@protoc_insertion_point(field_get:Request.rt)
  return static_cast< ::Request_ReturnType >(rt_);
}
inline void Request::set_rt(::Request_ReturnType value) {
  assert(::Request_ReturnType_IsValid(value));
  set_has_rt();
  rt_ = value;
  // @@protoc_insertion_point(field_set:Request.rt)
}

// required string q = 3;
inline bool Request::has_q() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_q() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_q() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_q() {
  q_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_q();
}
inline const ::std::string& Request::q() const {
  // @@protoc_insertion_point(field_get:Request.q)
  return q_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_q(const ::std::string& value) {
  set_has_q();
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Request.q)
}
inline void Request::set_q(const char* value) {
  set_has_q();
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Request.q)
}
inline void Request::set_q(const char* value, size_t size) {
  set_has_q();
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Request.q)
}
inline ::std::string* Request::mutable_q() {
  set_has_q();
  // @@protoc_insertion_point(field_mutable:Request.q)
  return q_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_q() {
  clear_has_q();
  return q_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_q(::std::string* q) {
  if (q != NULL) {
    set_has_q();
  } else {
    clear_has_q();
  }
  q_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), q);
  // @@protoc_insertion_point(field_set_allocated:Request.q)
}

// optional int32 k = 4;
inline bool Request::has_k() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_k() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_k() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_k() {
  k_ = 0;
  clear_has_k();
}
inline ::google::protobuf::int32 Request::k() const {
  // @@protoc_insertion_point(field_get:Request.k)
  return k_;
}
inline void Request::set_k(::google::protobuf::int32 value) {
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:Request.k)
}

// optional int32 s = 5;
inline bool Request::has_s() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_s() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_s() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_s() {
  s_ = 0;
  clear_has_s();
}
inline ::google::protobuf::int32 Request::s() const {
  // @@protoc_insertion_point(field_get:Request.s)
  return s_;
}
inline void Request::set_s(::google::protobuf::int32 value) {
  set_has_s();
  s_ = value;
  // @@protoc_insertion_point(field_set:Request.s)
}

// optional int32 p = 6;
inline bool Request::has_p() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_p() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_p() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline ::google::protobuf::int32 Request::p() const {
  // @@protoc_insertion_point(field_get:Request.p)
  return p_;
}
inline void Request::set_p(::google::protobuf::int32 value) {
  set_has_p();
  p_ = value;
  // @@protoc_insertion_point(field_set:Request.p)
}

// optional string a = 7;
inline bool Request::has_a() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_a() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_a() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_a() {
  a_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a();
}
inline const ::std::string& Request::a() const {
  // @@protoc_insertion_point(field_get:Request.a)
  return a_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_a(const ::std::string& value) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Request.a)
}
inline void Request::set_a(const char* value) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Request.a)
}
inline void Request::set_a(const char* value, size_t size) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Request.a)
}
inline ::std::string* Request::mutable_a() {
  set_has_a();
  // @@protoc_insertion_point(field_mutable:Request.a)
  return a_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_a() {
  clear_has_a();
  return a_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_a(::std::string* a) {
  if (a != NULL) {
    set_has_a();
  } else {
    clear_has_a();
  }
  a_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a);
  // @@protoc_insertion_point(field_set_allocated:Request.a)
}

// optional int32 isalt = 8;
inline bool Request::has_isalt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_isalt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_isalt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_isalt() {
  isalt_ = 0;
  clear_has_isalt();
}
inline ::google::protobuf::int32 Request::isalt() const {
  // @@protoc_insertion_point(field_get:Request.isalt)
  return isalt_;
}
inline void Request::set_isalt(::google::protobuf::int32 value) {
  set_has_isalt();
  isalt_ = value;
  // @@protoc_insertion_point(field_set:Request.isalt)
}

// -------------------------------------------------------------------

// ReadInfo

// required string g = 1;
inline bool ReadInfo::has_g() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadInfo::set_has_g() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadInfo::clear_has_g() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadInfo::clear_g() {
  g_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_g();
}
inline const ::std::string& ReadInfo::g() const {
  // @@protoc_insertion_point(field_get:ReadInfo.g)
  return g_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadInfo::set_g(const ::std::string& value) {
  set_has_g();
  g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ReadInfo.g)
}
inline void ReadInfo::set_g(const char* value) {
  set_has_g();
  g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ReadInfo.g)
}
inline void ReadInfo::set_g(const char* value, size_t size) {
  set_has_g();
  g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ReadInfo.g)
}
inline ::std::string* ReadInfo::mutable_g() {
  set_has_g();
  // @@protoc_insertion_point(field_mutable:ReadInfo.g)
  return g_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadInfo::release_g() {
  clear_has_g();
  return g_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadInfo::set_allocated_g(::std::string* g) {
  if (g != NULL) {
    set_has_g();
  } else {
    clear_has_g();
  }
  g_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g);
  // @@protoc_insertion_point(field_set_allocated:ReadInfo.g)
}

// required int32 c = 2;
inline bool ReadInfo::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadInfo::set_has_c() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadInfo::clear_has_c() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadInfo::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline ::google::protobuf::int32 ReadInfo::c() const {
  // @@protoc_insertion_point(field_get:ReadInfo.c)
  return c_;
}
inline void ReadInfo::set_c(::google::protobuf::int32 value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:ReadInfo.c)
}

// required int32 l = 3;
inline bool ReadInfo::has_l() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReadInfo::set_has_l() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReadInfo::clear_has_l() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReadInfo::clear_l() {
  l_ = 0;
  clear_has_l();
}
inline ::google::protobuf::int32 ReadInfo::l() const {
  // @@protoc_insertion_point(field_get:ReadInfo.l)
  return l_;
}
inline void ReadInfo::set_l(::google::protobuf::int32 value) {
  set_has_l();
  l_ = value;
  // @@protoc_insertion_point(field_set:ReadInfo.l)
}

// -------------------------------------------------------------------

// ResultSamples

// repeated .ReadInfo s = 1;
inline int ResultSamples::s_size() const {
  return s_.size();
}
inline void ResultSamples::clear_s() {
  s_.Clear();
}
inline const ::ReadInfo& ResultSamples::s(int index) const {
  // @@protoc_insertion_point(field_get:ResultSamples.s)
  return s_.Get(index);
}
inline ::ReadInfo* ResultSamples::mutable_s(int index) {
  // @@protoc_insertion_point(field_mutable:ResultSamples.s)
  return s_.Mutable(index);
}
inline ::ReadInfo* ResultSamples::add_s() {
  // @@protoc_insertion_point(field_add:ResultSamples.s)
  return s_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ReadInfo >*
ResultSamples::mutable_s() {
  // @@protoc_insertion_point(field_mutable_list:ResultSamples.s)
  return &s_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ReadInfo >&
ResultSamples::s() const {
  // @@protoc_insertion_point(field_list:ResultSamples.s)
  return s_;
}

// -------------------------------------------------------------------

// ResultAll

// required string r = 1;
inline bool ResultAll::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultAll::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultAll::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultAll::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_r();
}
inline const ::std::string& ResultAll::r() const {
  // @@protoc_insertion_point(field_get:ResultAll.r)
  return r_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultAll::set_r(const ::std::string& value) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResultAll.r)
}
inline void ResultAll::set_r(const char* value) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResultAll.r)
}
inline void ResultAll::set_r(const char* value, size_t size) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResultAll.r)
}
inline ::std::string* ResultAll::mutable_r() {
  set_has_r();
  // @@protoc_insertion_point(field_mutable:ResultAll.r)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultAll::release_r() {
  clear_has_r();
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultAll::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    set_has_r();
  } else {
    clear_has_r();
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:ResultAll.r)
}

// repeated .ReadInfo s = 2;
inline int ResultAll::s_size() const {
  return s_.size();
}
inline void ResultAll::clear_s() {
  s_.Clear();
}
inline const ::ReadInfo& ResultAll::s(int index) const {
  // @@protoc_insertion_point(field_get:ResultAll.s)
  return s_.Get(index);
}
inline ::ReadInfo* ResultAll::mutable_s(int index) {
  // @@protoc_insertion_point(field_mutable:ResultAll.s)
  return s_.Mutable(index);
}
inline ::ReadInfo* ResultAll::add_s() {
  // @@protoc_insertion_point(field_add:ResultAll.s)
  return s_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ReadInfo >*
ResultAll::mutable_s() {
  // @@protoc_insertion_point(field_mutable_list:ResultAll.s)
  return &s_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ReadInfo >&
ResultAll::s() const {
  // @@protoc_insertion_point(field_list:ResultAll.s)
  return s_;
}

// -------------------------------------------------------------------

// ResultCount

// required int32 c = 1;
inline bool ResultCount::has_c() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultCount::set_has_c() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultCount::clear_has_c() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultCount::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline ::google::protobuf::int32 ResultCount::c() const {
  // @@protoc_insertion_point(field_get:ResultCount.c)
  return c_;
}
inline void ResultCount::set_c(::google::protobuf::int32 value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:ResultCount.c)
}

// -------------------------------------------------------------------

// ResultReads

// required string r = 1;
inline bool ResultReads::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultReads::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultReads::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultReads::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_r();
}
inline const ::std::string& ResultReads::r() const {
  // @@protoc_insertion_point(field_get:ResultReads.r)
  return r_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultReads::set_r(const ::std::string& value) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResultReads.r)
}
inline void ResultReads::set_r(const char* value) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResultReads.r)
}
inline void ResultReads::set_r(const char* value, size_t size) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResultReads.r)
}
inline ::std::string* ResultReads::mutable_r() {
  set_has_r();
  // @@protoc_insertion_point(field_mutable:ResultReads.r)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultReads::release_r() {
  clear_has_r();
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultReads::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    set_has_r();
  } else {
    clear_has_r();
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:ResultReads.r)
}

// -------------------------------------------------------------------

// Reply

// required .Reply.RequestType rt = 1;
inline bool Reply::has_rt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply::set_has_rt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply::clear_has_rt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply::clear_rt() {
  rt_ = 1;
  clear_has_rt();
}
inline ::Reply_RequestType Reply::rt() const {
  // @@protoc_insertion_point(field_get:Reply.rt)
  return static_cast< ::Reply_RequestType >(rt_);
}
inline void Reply::set_rt(::Reply_RequestType value) {
  assert(::Reply_RequestType_IsValid(value));
  set_has_rt();
  rt_ = value;
  // @@protoc_insertion_point(field_set:Reply.rt)
}

// required .Reply.ReplyType t = 2;
inline bool Reply::has_t() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply::set_has_t() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply::clear_has_t() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply::clear_t() {
  t_ = 1;
  clear_has_t();
}
inline ::Reply_ReplyType Reply::t() const {
  // @@protoc_insertion_point(field_get:Reply.t)
  return static_cast< ::Reply_ReplyType >(t_);
}
inline void Reply::set_t(::Reply_ReplyType value) {
  assert(::Reply_ReplyType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:Reply.t)
}

// required string q = 3;
inline bool Reply::has_q() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply::set_has_q() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply::clear_has_q() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply::clear_q() {
  q_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_q();
}
inline const ::std::string& Reply::q() const {
  // @@protoc_insertion_point(field_get:Reply.q)
  return q_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_q(const ::std::string& value) {
  set_has_q();
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Reply.q)
}
inline void Reply::set_q(const char* value) {
  set_has_q();
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Reply.q)
}
inline void Reply::set_q(const char* value, size_t size) {
  set_has_q();
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Reply.q)
}
inline ::std::string* Reply::mutable_q() {
  set_has_q();
  // @@protoc_insertion_point(field_mutable:Reply.q)
  return q_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reply::release_q() {
  clear_has_q();
  return q_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_allocated_q(::std::string* q) {
  if (q != NULL) {
    set_has_q();
  } else {
    clear_has_q();
  }
  q_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), q);
  // @@protoc_insertion_point(field_set_allocated:Reply.q)
}

// optional .ReplyCount c = 4;
inline bool Reply::has_c() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply::set_has_c() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply::clear_has_c() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply::clear_c() {
  if (c_ != NULL) c_->::ReplyCount::Clear();
  clear_has_c();
}
inline const ::ReplyCount& Reply::c() const {
  // @@protoc_insertion_point(field_get:Reply.c)
  return c_ != NULL ? *c_ : *default_instance_->c_;
}
inline ::ReplyCount* Reply::mutable_c() {
  set_has_c();
  if (c_ == NULL) {
    c_ = new ::ReplyCount;
  }
  // @@protoc_insertion_point(field_mutable:Reply.c)
  return c_;
}
inline ::ReplyCount* Reply::release_c() {
  clear_has_c();
  ::ReplyCount* temp = c_;
  c_ = NULL;
  return temp;
}
inline void Reply::set_allocated_c(::ReplyCount* c) {
  delete c_;
  c_ = c;
  if (c) {
    set_has_c();
  } else {
    clear_has_c();
  }
  // @@protoc_insertion_point(field_set_allocated:Reply.c)
}

// optional .ReplyReads r = 5;
inline bool Reply::has_r() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply::set_has_r() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply::clear_has_r() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply::clear_r() {
  if (r_ != NULL) r_->::ReplyReads::Clear();
  clear_has_r();
}
inline const ::ReplyReads& Reply::r() const {
  // @@protoc_insertion_point(field_get:Reply.r)
  return r_ != NULL ? *r_ : *default_instance_->r_;
}
inline ::ReplyReads* Reply::mutable_r() {
  set_has_r();
  if (r_ == NULL) {
    r_ = new ::ReplyReads;
  }
  // @@protoc_insertion_point(field_mutable:Reply.r)
  return r_;
}
inline ::ReplyReads* Reply::release_r() {
  clear_has_r();
  ::ReplyReads* temp = r_;
  r_ = NULL;
  return temp;
}
inline void Reply::set_allocated_r(::ReplyReads* r) {
  delete r_;
  r_ = r;
  if (r) {
    set_has_r();
  } else {
    clear_has_r();
  }
  // @@protoc_insertion_point(field_set_allocated:Reply.r)
}

// optional .ReplyAll a = 6;
inline bool Reply::has_a() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply::set_has_a() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply::clear_has_a() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply::clear_a() {
  if (a_ != NULL) a_->::ReplyAll::Clear();
  clear_has_a();
}
inline const ::ReplyAll& Reply::a() const {
  // @@protoc_insertion_point(field_get:Reply.a)
  return a_ != NULL ? *a_ : *default_instance_->a_;
}
inline ::ReplyAll* Reply::mutable_a() {
  set_has_a();
  if (a_ == NULL) {
    a_ = new ::ReplyAll;
  }
  // @@protoc_insertion_point(field_mutable:Reply.a)
  return a_;
}
inline ::ReplyAll* Reply::release_a() {
  clear_has_a();
  ::ReplyAll* temp = a_;
  a_ = NULL;
  return temp;
}
inline void Reply::set_allocated_a(::ReplyAll* a) {
  delete a_;
  a_ = a;
  if (a) {
    set_has_a();
  } else {
    clear_has_a();
  }
  // @@protoc_insertion_point(field_set_allocated:Reply.a)
}

// optional .ResultSamples s = 7;
inline bool Reply::has_s() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply::set_has_s() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply::clear_has_s() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply::clear_s() {
  if (s_ != NULL) s_->::ResultSamples::Clear();
  clear_has_s();
}
inline const ::ResultSamples& Reply::s() const {
  // @@protoc_insertion_point(field_get:Reply.s)
  return s_ != NULL ? *s_ : *default_instance_->s_;
}
inline ::ResultSamples* Reply::mutable_s() {
  set_has_s();
  if (s_ == NULL) {
    s_ = new ::ResultSamples;
  }
  // @@protoc_insertion_point(field_mutable:Reply.s)
  return s_;
}
inline ::ResultSamples* Reply::release_s() {
  clear_has_s();
  ::ResultSamples* temp = s_;
  s_ = NULL;
  return temp;
}
inline void Reply::set_allocated_s(::ResultSamples* s) {
  delete s_;
  s_ = s;
  if (s) {
    set_has_s();
  } else {
    clear_has_s();
  }
  // @@protoc_insertion_point(field_set_allocated:Reply.s)
}

// -------------------------------------------------------------------

// ReplyAll

// repeated .ResultAll forward_matches = 1;
inline int ReplyAll::forward_matches_size() const {
  return forward_matches_.size();
}
inline void ReplyAll::clear_forward_matches() {
  forward_matches_.Clear();
}
inline const ::ResultAll& ReplyAll::forward_matches(int index) const {
  // @@protoc_insertion_point(field_get:ReplyAll.forward_matches)
  return forward_matches_.Get(index);
}
inline ::ResultAll* ReplyAll::mutable_forward_matches(int index) {
  // @@protoc_insertion_point(field_mutable:ReplyAll.forward_matches)
  return forward_matches_.Mutable(index);
}
inline ::ResultAll* ReplyAll::add_forward_matches() {
  // @@protoc_insertion_point(field_add:ReplyAll.forward_matches)
  return forward_matches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ResultAll >*
ReplyAll::mutable_forward_matches() {
  // @@protoc_insertion_point(field_mutable_list:ReplyAll.forward_matches)
  return &forward_matches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ResultAll >&
ReplyAll::forward_matches() const {
  // @@protoc_insertion_point(field_list:ReplyAll.forward_matches)
  return forward_matches_;
}

// repeated .ResultAll revcomp_matches = 2;
inline int ReplyAll::revcomp_matches_size() const {
  return revcomp_matches_.size();
}
inline void ReplyAll::clear_revcomp_matches() {
  revcomp_matches_.Clear();
}
inline const ::ResultAll& ReplyAll::revcomp_matches(int index) const {
  // @@protoc_insertion_point(field_get:ReplyAll.revcomp_matches)
  return revcomp_matches_.Get(index);
}
inline ::ResultAll* ReplyAll::mutable_revcomp_matches(int index) {
  // @@protoc_insertion_point(field_mutable:ReplyAll.revcomp_matches)
  return revcomp_matches_.Mutable(index);
}
inline ::ResultAll* ReplyAll::add_revcomp_matches() {
  // @@protoc_insertion_point(field_add:ReplyAll.revcomp_matches)
  return revcomp_matches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ResultAll >*
ReplyAll::mutable_revcomp_matches() {
  // @@protoc_insertion_point(field_mutable_list:ReplyAll.revcomp_matches)
  return &revcomp_matches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ResultAll >&
ReplyAll::revcomp_matches() const {
  // @@protoc_insertion_point(field_list:ReplyAll.revcomp_matches)
  return revcomp_matches_;
}

// -------------------------------------------------------------------

// ReplyCount

// optional .ResultCount forward_matches = 1;
inline bool ReplyCount::has_forward_matches() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyCount::set_has_forward_matches() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyCount::clear_has_forward_matches() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyCount::clear_forward_matches() {
  if (forward_matches_ != NULL) forward_matches_->::ResultCount::Clear();
  clear_has_forward_matches();
}
inline const ::ResultCount& ReplyCount::forward_matches() const {
  // @@protoc_insertion_point(field_get:ReplyCount.forward_matches)
  return forward_matches_ != NULL ? *forward_matches_ : *default_instance_->forward_matches_;
}
inline ::ResultCount* ReplyCount::mutable_forward_matches() {
  set_has_forward_matches();
  if (forward_matches_ == NULL) {
    forward_matches_ = new ::ResultCount;
  }
  // @@protoc_insertion_point(field_mutable:ReplyCount.forward_matches)
  return forward_matches_;
}
inline ::ResultCount* ReplyCount::release_forward_matches() {
  clear_has_forward_matches();
  ::ResultCount* temp = forward_matches_;
  forward_matches_ = NULL;
  return temp;
}
inline void ReplyCount::set_allocated_forward_matches(::ResultCount* forward_matches) {
  delete forward_matches_;
  forward_matches_ = forward_matches;
  if (forward_matches) {
    set_has_forward_matches();
  } else {
    clear_has_forward_matches();
  }
  // @@protoc_insertion_point(field_set_allocated:ReplyCount.forward_matches)
}

// optional .ResultCount revcomp_matches = 2;
inline bool ReplyCount::has_revcomp_matches() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyCount::set_has_revcomp_matches() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyCount::clear_has_revcomp_matches() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyCount::clear_revcomp_matches() {
  if (revcomp_matches_ != NULL) revcomp_matches_->::ResultCount::Clear();
  clear_has_revcomp_matches();
}
inline const ::ResultCount& ReplyCount::revcomp_matches() const {
  // @@protoc_insertion_point(field_get:ReplyCount.revcomp_matches)
  return revcomp_matches_ != NULL ? *revcomp_matches_ : *default_instance_->revcomp_matches_;
}
inline ::ResultCount* ReplyCount::mutable_revcomp_matches() {
  set_has_revcomp_matches();
  if (revcomp_matches_ == NULL) {
    revcomp_matches_ = new ::ResultCount;
  }
  // @@protoc_insertion_point(field_mutable:ReplyCount.revcomp_matches)
  return revcomp_matches_;
}
inline ::ResultCount* ReplyCount::release_revcomp_matches() {
  clear_has_revcomp_matches();
  ::ResultCount* temp = revcomp_matches_;
  revcomp_matches_ = NULL;
  return temp;
}
inline void ReplyCount::set_allocated_revcomp_matches(::ResultCount* revcomp_matches) {
  delete revcomp_matches_;
  revcomp_matches_ = revcomp_matches;
  if (revcomp_matches) {
    set_has_revcomp_matches();
  } else {
    clear_has_revcomp_matches();
  }
  // @@protoc_insertion_point(field_set_allocated:ReplyCount.revcomp_matches)
}

// -------------------------------------------------------------------

// ReplyReads

// repeated .ResultReads forward_matches = 1;
inline int ReplyReads::forward_matches_size() const {
  return forward_matches_.size();
}
inline void ReplyReads::clear_forward_matches() {
  forward_matches_.Clear();
}
inline const ::ResultReads& ReplyReads::forward_matches(int index) const {
  // @@protoc_insertion_point(field_get:ReplyReads.forward_matches)
  return forward_matches_.Get(index);
}
inline ::ResultReads* ReplyReads::mutable_forward_matches(int index) {
  // @@protoc_insertion_point(field_mutable:ReplyReads.forward_matches)
  return forward_matches_.Mutable(index);
}
inline ::ResultReads* ReplyReads::add_forward_matches() {
  // @@protoc_insertion_point(field_add:ReplyReads.forward_matches)
  return forward_matches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ResultReads >*
ReplyReads::mutable_forward_matches() {
  // @@protoc_insertion_point(field_mutable_list:ReplyReads.forward_matches)
  return &forward_matches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ResultReads >&
ReplyReads::forward_matches() const {
  // @@protoc_insertion_point(field_list:ReplyReads.forward_matches)
  return forward_matches_;
}

// repeated .ResultReads revcomp_matches = 2;
inline int ReplyReads::revcomp_matches_size() const {
  return revcomp_matches_.size();
}
inline void ReplyReads::clear_revcomp_matches() {
  revcomp_matches_.Clear();
}
inline const ::ResultReads& ReplyReads::revcomp_matches(int index) const {
  // @@protoc_insertion_point(field_get:ReplyReads.revcomp_matches)
  return revcomp_matches_.Get(index);
}
inline ::ResultReads* ReplyReads::mutable_revcomp_matches(int index) {
  // @@protoc_insertion_point(field_mutable:ReplyReads.revcomp_matches)
  return revcomp_matches_.Mutable(index);
}
inline ::ResultReads* ReplyReads::add_revcomp_matches() {
  // @@protoc_insertion_point(field_add:ReplyReads.revcomp_matches)
  return revcomp_matches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ResultReads >*
ReplyReads::mutable_revcomp_matches() {
  // @@protoc_insertion_point(field_mutable_list:ReplyReads.revcomp_matches)
  return &revcomp_matches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ResultReads >&
ReplyReads::revcomp_matches() const {
  // @@protoc_insertion_point(field_list:ReplyReads.revcomp_matches)
  return revcomp_matches_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Request_RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Request_RequestType>() {
  return ::Request_RequestType_descriptor();
}
template <> struct is_proto_enum< ::Request_ReturnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Request_ReturnType>() {
  return ::Request_ReturnType_descriptor();
}
template <> struct is_proto_enum< ::Reply_RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_RequestType>() {
  return ::Reply_RequestType_descriptor();
}
template <> struct is_proto_enum< ::Reply_ReplyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_ReplyType>() {
  return ::Reply_ReplyType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_readserver_2eproto__INCLUDED
